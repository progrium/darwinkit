package codegen

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/progrium/macdriver/generate/modules"
	"github.com/progrium/macdriver/generate/typing"
	"github.com/progrium/macdriver/internal/set"
	"github.com/progrium/macdriver/internal/stringx"
)

// CodeGen is interface for Class/Protocol code Gen
type CodeGen interface {
	Init()
	Copy() CodeGen
	GoImports() set.Set[string]
	WriteGoCode(cw *CodeWriter)
}

// ModuleWriter mantains module level auto-generated code source files
type ModuleWriter struct {
	Module      modules.Module
	CodeFileDir string
	Protocols   []*typing.ProtocolType
	Aliases     []*EnumInfo
}

func (m *ModuleWriter) WriteCode() {
	m.WriteAliasesCode()
	m.WriteProtocolsImportCode()
}

func (m *ModuleWriter) WriteAliasesCode() {
	enums := make([]*EnumInfo, len(m.Aliases))
	copy(enums, m.Aliases)
	sort.Slice(enums, func(i, j int) bool {
		return enums[i].Name < enums[j].Name
	})

	log.Println("gen enums for", m.Module.Name)
	name := stringx.CamelToSnake(strings.ReplaceAll(m.Module.Name, "Kit", "kit"))
	filePath := filepath.Join(m.CodeFileDir, m.Module.Package, name+"_enums.go")
	arm64FilePath := filepath.Join(m.CodeFileDir, m.Module.Package, name+"_enums_arm64.go")
	amd64FilePath := filepath.Join(m.CodeFileDir, m.Module.Package, name+"_enums_amd64.go")
	os.MkdirAll(filepath.Dir(filePath), 0755)
	f, err := os.Create(filePath)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	arm64F, err := os.Create(arm64FilePath)
	if err != nil {
		panic(err)
	}
	defer arm64F.Close()
	amd64F, err := os.Create(amd64FilePath)
	if err != nil {
		panic(err)
	}
	defer amd64F.Close()

	cw := &CodeWriter{Writer: f, IndentStr: "\t"}
	cw.WriteLine(AutoGeneratedMark)
	cw.WriteLine("package " + m.Module.Package)
	arm64CW := &CodeWriter{Writer: arm64F, IndentStr: "\t"}
	arm64CW.WriteLine(AutoGeneratedMark)
	arm64CW.WriteLine("package " + m.Module.Package)
	amd64CW := &CodeWriter{Writer: amd64F, IndentStr: "\t"}
	amd64CW.WriteLine(AutoGeneratedMark)
	amd64CW.WriteLine("package " + m.Module.Package)

	for _, ei := range enums {
		if ei.Module.Name == m.Module.Name {
			cw.WriteLine(fmt.Sprintf("type %s %s", ei.GName, ei.Type.GoName(&m.Module, false)))
		}
		for _, v := range ei.Values {
			if v.Module == nil {
				continue
			}
			if v.Module.Name != m.Module.Name {
				// TODO: just skip it for now...
				continue
			}
			if v.Value == "" {
				log.Println("enum ", v.Name, " requires a value")
				continue
			}
			if v.Arm64Value != "" {
				if !ei.IsString() {
					amd64CW.WriteLine(fmt.Sprintf("const %s %s = %s", v.GoName, ei.GoName(&m.Module, false), v.Value))
					arm64CW.WriteLine(fmt.Sprintf("const %s %s = %s", v.GoName, ei.GoName(&m.Module, false), v.Arm64Value))
				} else {
					amd64CW.WriteLine(fmt.Sprintf("const %s %s = \"%s\"", v.GoName, ei.GoName(&m.Module, false), v.Value))
					arm64CW.WriteLine(fmt.Sprintf("const %s %s = \"%s\"", v.GoName, ei.GoName(&m.Module, false), v.Arm64Value))
				}
			} else {
				if !ei.IsString() {
					cw.WriteLine(fmt.Sprintf("const %s %s = %s", v.GoName, ei.GoName(&m.Module, false), v.Value))
				} else {
					cw.WriteLine(fmt.Sprintf("const %s %s = \"%s\"", v.GoName, ei.GoName(&m.Module, false), v.Value))
				}
			}
		}
	}

}

func (m *ModuleWriter) WriteProtocolsImportCode() {
	log.Println("gen protocol imports for", m.Module.Name)
	ps := make([]*typing.ProtocolType, len(m.Protocols))
	copy(ps, m.Protocols)
	sort.Slice(ps, func(i, j int) bool {
		return ps[i].Name < ps[j].Name
	})
	name := stringx.CamelToSnake(strings.ReplaceAll(m.Module.Name, "Kit", "kit"))
	m.writeProtocolMFile(ps, filepath.Join(m.CodeFileDir, m.Module.Package, name+"_protocols.m"))
	// m.writeProtocolGoFile(ps, filepath.Join(m.CodeFileDir, m.Module.Package, name+"_protocols.go"))
}

func (m *ModuleWriter) writeProtocolMFile(protocols []*typing.ProtocolType, filePath string) {
	f, err := os.Create(filePath)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	cw := &CodeWriter{Writer: f, IndentStr: "    "}
	cw.WriteLine(AutoGeneratedMark)
	cw.WriteLineF("#import \"%s\"", m.Module.Header)
	cw.WriteLine("")

	cw.WriteLineF("void import%sProtocols() {", m.Module.Name)
	cw.Indent()
	cw.WriteLine("id o;")
	for _, protocol := range protocols {
		cw.WriteLineF("o = @protocol(%s);", protocol.Name)
	}
	cw.UnIndent()
	cw.WriteLine("}")
}

func (m *ModuleWriter) writeProtocolGoFile(protocols []*typing.ProtocolType, filePath string) {
	f, err := os.Create(filePath)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	cw := &CodeWriter{Writer: f, IndentStr: "\t"}
	cw.WriteLine(AutoGeneratedMark)
	cw.WriteLine("package " + m.Module.Package)
	cw.WriteLine("import \"github.com/progrium/macdriver/objc\"")
	cw.WriteLine("func init() {")
	cw.Indent()

	for _, protocol := range protocols {
		cw.WriteLineF("objc.RegisterProtocol(\"%s.%s\", objc.ProtocolInfo{Name:\"%s\"})", protocol.Module.Package, protocol.GName, protocol.Name)
	}
	cw.UnIndent()
	cw.WriteLine("}")
}
