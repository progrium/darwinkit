package codegen

import (
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/progrium/macdriver/generate/modules"
	"github.com/progrium/macdriver/generate/typing"
	"github.com/progrium/macdriver/internal/set"
)

// CodeGen is interface for Class/Protocol code Gen
type CodeGen interface {
	Init()
	Copy() CodeGen
	GoImports() set.Set[string]
	WriteGoCode(cw *CodeWriter)
}

// ModuleWriter mantains module level auto-generated code source files
type ModuleWriter struct {
	Module      modules.Module
	PlatformDir string
	Protocols   []*typing.ProtocolType
	Aliases     []*EnumInfo
}

func (m *ModuleWriter) WriteCode() {
	m.WriteAliasesCode()
	m.WriteProtocolsImportCode()
}

func (m *ModuleWriter) WriteAliasesCode() {
	enums := make([]*EnumInfo, len(m.Aliases))
	copy(enums, m.Aliases)
	sort.Slice(enums, func(i, j int) bool {
		return enums[i].Name < enums[j].Name
	})

	if len(enums) == 0 {
		return
	}
	armVals := false
	for _, e := range enums {
		for _, v := range e.Values {
			if v.Arm64Value != "" {
				armVals = true
			}
		}
	}

	//log.Println("gen enums for", m.Module.Name)

	filePath := filepath.Join(m.PlatformDir, m.Module.Package, "enumtypes.gen.go")
	os.MkdirAll(filepath.Dir(filePath), 0755)
	f, err := os.Create(filePath)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	var arm64f io.Writer = io.Discard
	var amd64f io.Writer = io.Discard
	if armVals {
		armf, err := os.Create(filepath.Join(m.PlatformDir, m.Module.Package, "enumtypes_arm64.gen.go"))
		if err != nil {
			panic(err)
		}
		defer armf.Close()
		arm64f = armf
		amdf, err := os.Create(filepath.Join(m.PlatformDir, m.Module.Package, "enumtypes_amd64.gen.go"))
		if err != nil {
			panic(err)
		}
		defer amdf.Close()
		amd64f = amdf
	}

	cw := &CodeWriter{Writer: f, IndentStr: "\t"}
	cw.WriteLine(AutoGeneratedMark)
	cw.WriteLine("package " + m.Module.Package)

	arm64cw := &CodeWriter{Writer: arm64f, IndentStr: "\t"}
	arm64cw.WriteLine(AutoGeneratedMark)
	arm64cw.WriteLine("package " + m.Module.Package)

	amd64cw := &CodeWriter{Writer: amd64f, IndentStr: "\t"}
	amd64cw.WriteLine(AutoGeneratedMark)
	amd64cw.WriteLine("package " + m.Module.Package)

	for _, ei := range enums {
		primitiveType := ei.Type.GoName(&m.Module, false)
		if ei.Module.Name == m.Module.Name {
			if ei.Name == "CGFloat" {
				// special case CGFloat to be an actual type alias
				cw.WriteLine(fmt.Sprintf("type %s = %s\n", ei.GName, primitiveType))
			} else {
				cw.WriteLine(fmt.Sprintf("type %s %s\n", ei.GName, primitiveType))
			}
		}
		sort.Slice(ei.Values, func(i, j int) bool {
			return ei.Values[i].Name < ei.Values[j].Name
		})
		for _, v := range ei.Values {
			if v.Module == nil {
				continue
			}
			if v.Module.Name != m.Module.Name {
				// TODO: just skip it for now...
				continue
			}
			c := modules.LookupConstant("macos", m.Module.Package, v.Name)
			if c == nil {
				log.Println("MISSING CONSTANT:", v.Name)
			}
			if c != nil {
				v.Value = c.Value
				v.Arm64Value = c.ArmValue
			}
			if primitiveType == "uint" || primitiveType == "uint64" {
				// special cases maybe we wouldn't need if we exported properly
				if v.Value == "-1" {
					v.Value = "math.MaxUint"
					if v.Arm64Value != "" {
						v.Arm64Value = "math.MaxUint"
					}
				} else if strings.HasPrefix(v.Value, "-") {
					v.Value = strings.TrimPrefix(v.Value, "-")
					if v.Arm64Value != "" {
						v.Arm64Value = strings.TrimPrefix(v.Arm64Value, "-")
					}
				}
			}
			if v.Value == "" {
				log.Println("enum ", v.Name, " requires a value")
				continue
			}
			if v.Arm64Value != "" {
				if !ei.IsString() {
					amd64cw.WriteLine(fmt.Sprintf("const %s %s = %s", v.GoName, ei.GoName(&m.Module, false), v.Value))
					arm64cw.WriteLine(fmt.Sprintf("const %s %s = %s", v.GoName, ei.GoName(&m.Module, false), v.Arm64Value))
				} else {
					amd64cw.WriteLine(fmt.Sprintf("const %s %s = \"%s\"", v.GoName, ei.GoName(&m.Module, false), v.Value))
					arm64cw.WriteLine(fmt.Sprintf("const %s %s = \"%s\"", v.GoName, ei.GoName(&m.Module, false), v.Arm64Value))
				}
			} else {
				if !ei.IsString() {
					cw.WriteLine(fmt.Sprintf("const %s %s = %s", v.GoName, ei.GoName(&m.Module, false), v.Value))
				} else {
					cw.WriteLine(fmt.Sprintf("const %s %s = \"%s\"", v.GoName, ei.GoName(&m.Module, false), v.Value))
				}
			}
		}
	}

}

func (m *ModuleWriter) WriteProtocolsImportCode() {
	//log.Println("gen protocol imports for", m.Module.Name)
	ps := make([]*typing.ProtocolType, len(m.Protocols))
	copy(ps, m.Protocols)
	sort.Slice(ps, func(i, j int) bool {
		return ps[i].Name < ps[j].Name
	})
	m.writeProtocolMFile(ps, filepath.Join(m.PlatformDir, m.Module.Package, "protocols.gen.m"))
}

func (m *ModuleWriter) writeProtocolMFile(protocols []*typing.ProtocolType, filePath string) {
	f, err := os.Create(filePath)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	cw := &CodeWriter{Writer: f, IndentStr: "    "}
	cw.WriteLine(AutoGeneratedMark)
	cw.WriteLineF("#import \"%s\"", m.Module.Header)
	cw.WriteLine("")

	cw.WriteLineF("void import%sProtocols() {", m.Module.Name)
	cw.Indent()
	cw.WriteLine("id o;")
	for _, protocol := range protocols {
		cw.WriteLineF("o = @protocol(%s);", protocol.Name)
	}
	cw.UnIndent()
	cw.WriteLine("}")
}
